<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Uwt_compat.html">
<link rel="next" href="Uwt_preemptive.html">
<link rel="Up" href="index.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Uv_fs_sync" rel="Chapter" href="Uv_fs_sync.html">
<link title="Uwt" rel="Chapter" href="Uwt.html">
<link title="Uwt_base" rel="Chapter" href="Uwt_base.html">
<link title="Uwt_bytes" rel="Chapter" href="Uwt_bytes.html">
<link title="Uwt_compat" rel="Chapter" href="Uwt_compat.html">
<link title="Uwt_io" rel="Chapter" href="Uwt_io.html">
<link title="Uwt_preemptive" rel="Chapter" href="Uwt_preemptive.html">
<link title="Uwt_process" rel="Chapter" href="Uwt_process.html">
<link title="Uwt_throttle" rel="Chapter" href="Uwt_throttle.html">
<link title="Uwt_timeout" rel="Chapter" href="Uwt_timeout.html"><link title="Types" rel="Section" href="#2_Types">
<link title="Well-known instances" rel="Section" href="#2_Wellknowninstances">
<link title="Channels creation/manipulation" rel="Section" href="#2_Channelscreationmanipulation">
<link title="Random access" rel="Section" href="#2_Randomaccess">
<link title="Reading" rel="Section" href="#2_Reading">
<link title="Writing" rel="Section" href="#2_Writing">
<link title="Printing" rel="Section" href="#2_Printing">
<link title="Utilities" rel="Section" href="#2_Utilities">
<link title="File utilities" rel="Section" href="#2_Fileutilities">
<link title="Input/output of integers" rel="Section" href="#2_Inputoutputofintegers">
<link title="Low-level access to the internal buffer" rel="Section" href="#2_Lowlevelaccesstotheinternalbuffer">
<link title="Misc" rel="Section" href="#2_Misc">
<title>Uwt - OCaml bindings for libuv : Uwt_io</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Uwt_compat.html" title="Uwt_compat">Previous</a>
&nbsp;<a class="up" href="index.html" title="Index">Up</a>
&nbsp;<a class="post" href="Uwt_preemptive.html" title="Uwt_preemptive">Next</a>
</div>
<h1>Module <a href="type_Uwt_io.html">Uwt_io</a></h1>

<pre><span id="MODULEUwt_io"><span class="keyword">module</span> Uwt_io</span>: <code class="code">sig</code> <a href="Uwt_io.html">..</a> <code class="code">end</code></pre><div class="info module top">
<div class="info-desc">
<p>Buffered byte channels</p>
</div>
</div>
<hr width="100%">
<p>A <b>channel</b> is a high-level object for performing input/output
    (IO). It allows to read/write from/to the outside world in an
    efficient way, by minimising the number of system calls.</p>

<p>An <b>output channel</b> is used to send data and an <b>input
    channel</b> is used to receive data.</p>

<p>If you are familiar with buffered channels you may be familiar too
    with the <b>flush</b> operation. Note that byte channels of this
    module are automatically flushed when there is nothing else to do
    (i.e. before the program becomes idle), so this means that you no
    longer have to write:</p>

<pre class="codepre"><code class="code">      eprintf "log message\n";
      flush stderr;
    </code></pre>
<p>to have your messages displayed.</p>

<p>Note about errors: input functions of this module raise
    <code class="code">End_of_file</code> when the end-of-file is reached (i.e. when the read
    function returns <code class="code">0</code>). Other exceptions are ones caused by the
    backend read/write functions, such as <code class="code">Unix.Unix_error</code>.</p>

<pre><span id="EXCEPTIONChannel_closed"><span class="keyword">exception</span> Channel_closed</span> <span class="keyword">of</span> <code class="type">string</code></pre>
<div class="info ">
<div class="info-desc">
<p>Exception raised when a channel is closed. The parameter is a
      description of the channel.</p>
</div>
</div>
<h3 id="2_Types">Types</h3>
<pre><span id="TYPEchannel"><span class="keyword">type</span> <code class="type">'mode</code> channel</span> </pre>
<div class="info ">
<div class="info-desc">
<p>Type of buffered byte channels</p>
</div>
</div>


<pre><span id="TYPEinput"><span class="keyword">type</span> <code class="type"></code>input</span> </pre>
<div class="info ">
<div class="info-desc">
<p>Input mode</p>
</div>
</div>


<pre><span id="TYPEoutput"><span class="keyword">type</span> <code class="type"></code>output</span> </pre>
<div class="info ">
<div class="info-desc">
<p>Output mode</p>
</div>
</div>


<pre><code><span id="TYPEmode"><span class="keyword">type</span> <code class="type">'a</code> mode</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTmode.Input"><span class="constructor">Input</span></span> <span class="keyword">:</span> <code class="type"><a href="Uwt_io.html#TYPEinput">input</a> <a href="Uwt_io.html#TYPEmode">mode</a></code></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTmode.Output"><span class="constructor">Output</span></span> <span class="keyword">:</span> <code class="type"><a href="Uwt_io.html#TYPEoutput">output</a> <a href="Uwt_io.html#TYPEmode">mode</a></code></code></td>

</tr></table>

<div class="info ">
<div class="info-desc">
<p>Channel mode</p>
</div>
</div>


<pre><span id="VALinput"><span class="keyword">val</span> input</span> : <code class="type"><a href="Uwt_io.html#TYPEinput">input</a> <a href="Uwt_io.html#TYPEmode">mode</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">input</code> input mode representation</p>
</div>
</div>

<pre><span id="VALoutput"><span class="keyword">val</span> output</span> : <code class="type"><a href="Uwt_io.html#TYPEoutput">output</a> <a href="Uwt_io.html#TYPEmode">mode</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">output</code> output mode representation</p>
</div>
</div>

<pre><span id="TYPEinput_channel"><span class="keyword">type</span> <code class="type"></code>input_channel</span> = <code class="type"><a href="Uwt_io.html#TYPEinput">input</a> <a href="Uwt_io.html#TYPEchannel">channel</a></code> </pre>
<div class="info ">
<div class="info-desc">
<p>Type of input channels</p>
</div>
</div>


<pre><span id="TYPEoutput_channel"><span class="keyword">type</span> <code class="type"></code>output_channel</span> = <code class="type"><a href="Uwt_io.html#TYPEoutput">output</a> <a href="Uwt_io.html#TYPEchannel">channel</a></code> </pre>
<div class="info ">
<div class="info-desc">
<p>Type of output channels</p>
</div>
</div>


<pre><span id="VALmode"><span class="keyword">val</span> mode</span> : <code class="type">'a <a href="Uwt_io.html#TYPEchannel">channel</a> -> 'a <a href="Uwt_io.html#TYPEmode">mode</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">mode ch</code> returns the mode of a channel</p>
</div>
</div>
<h3 id="2_Wellknowninstances">Well-known instances</h3>
<pre><span id="VALstdin"><span class="keyword">val</span> stdin</span> : <code class="type"><a href="Uwt_io.html#TYPEinput_channel">input_channel</a></code></pre><div class="info ">
<div class="info-desc">
<p>The standard input, it reads data from <code class="code">Uwt.stdin</code></p>
</div>
</div>

<pre><span id="VALstdout"><span class="keyword">val</span> stdout</span> : <code class="type"><a href="Uwt_io.html#TYPEoutput_channel">output_channel</a></code></pre><div class="info ">
<div class="info-desc">
<p>The standard output, it writes data to <code class="code">Uwt.stdout</code></p>
</div>
</div>

<pre><span id="VALstderr"><span class="keyword">val</span> stderr</span> : <code class="type"><a href="Uwt_io.html#TYPEoutput_channel">output_channel</a></code></pre><div class="info ">
<div class="info-desc">
<p>The standard output for error messages, it writes data to
      <code class="code">Uwt.stderr</code></p>
</div>
</div>

<pre><span id="VALzero"><span class="keyword">val</span> zero</span> : <code class="type"><a href="Uwt_io.html#TYPEinput_channel">input_channel</a></code></pre><div class="info ">
<div class="info-desc">
<p>Inputs which returns always <code class="code">'\x00'</code></p>
</div>
</div>

<pre><span id="VALnull"><span class="keyword">val</span> null</span> : <code class="type"><a href="Uwt_io.html#TYPEoutput_channel">output_channel</a></code></pre><div class="info ">
<div class="info-desc">
<p>Output which drops everything</p>
</div>
</div>
<h3 id="2_Channelscreationmanipulation">Channels creation/manipulation</h3>
<pre><span id="VALpipe"><span class="keyword">val</span> pipe</span> : <code class="type">?cloexec:bool -><br>       ?in_buffer:<a href="Uwt_bytes.html#TYPEt">Uwt_bytes.t</a> -><br>       ?out_buffer:<a href="Uwt_bytes.html#TYPEt">Uwt_bytes.t</a> -><br>       unit -> <a href="Uwt_io.html#TYPEinput_channel">input_channel</a> * <a href="Uwt_io.html#TYPEoutput_channel">output_channel</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">pipe ?cloexec ?in_buffer ?out_buffer ()</code> creates a pipe using
      <a href="Uwt.Unix.html#VALpipe"><code class="code">Uwt.Unix.pipe</code></a> and makes two channels from the two returned file
      descriptors</p>
</div>
</div>

<pre><span id="VALmake"><span class="keyword">val</span> make</span> : <code class="type">?buffer:<a href="Uwt_bytes.html#TYPEt">Uwt_bytes.t</a> -><br>       ?close:(unit -> unit Lwt.t) -><br>       ?seek:(int64 -> Unix.seek_command -> int64 Lwt.t) -><br>       mode:'mode <a href="Uwt_io.html#TYPEmode">mode</a> -><br>       (<a href="Uwt_bytes.html#TYPEt">Uwt_bytes.t</a> -> int -> int -> int Lwt.t) -> 'mode <a href="Uwt_io.html#TYPEchannel">channel</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">make ?buffer ?close ~mode perform_io</code> is the
      main function for creating new channels.</p>
</div>
</div>
<div class="param_info"><code class="code">buffer</code> : user-supplied buffer. When this argument is
      present, its value will be used as the buffer for created
      channel. Size of buffer must conform to limitations described
      in <a href="Uwt_io.html#VALset_default_buffer_size"><code class="code">Uwt_io.set_default_buffer_size</code></a>.
      When this argument is not present, a new internal buffer of default
      size will be allocated for this channel.
      Warning: do not use the same buffer for simultaneous work with
      more than one channel.
      There are other functions in this module that take <code class="code">buffer</code>
      argument, their semantics agrees with the described above.</div>
<div class="param_info"><code class="code">close</code> : close function of the channel. It defaults to
      <code class="code">Lwt.return</code></div>
<div class="param_info"><code class="code">seek</code> : same meaning as <code class="code">Unix.lseek</code></div>
<div class="param_info"><code class="code">mode</code> : either <a href="Uwt_io.html#VALinput"><code class="code">Uwt_io.input</code></a> or <a href="Uwt_io.html#VALoutput"><code class="code">Uwt_io.output</code></a></div>

<pre><span id="VALof_bytes"><span class="keyword">val</span> of_bytes</span> : <code class="type">mode:'mode <a href="Uwt_io.html#TYPEmode">mode</a> -> <a href="Uwt_bytes.html#TYPEt">Uwt_bytes.t</a> -> 'mode <a href="Uwt_io.html#TYPEchannel">channel</a></code></pre><div class="info ">
<div class="info-desc">
<p>Create a channel from a byte array. Reading/writing is done
      directly on the provided array.</p>
</div>
</div>

<pre><span id="VALof_file"><span class="keyword">val</span> of_file</span> : <code class="type">?buffer:<a href="Uwt_bytes.html#TYPEt">Uwt_bytes.t</a> -><br>       ?close:(unit -> unit Lwt.t) -><br>       mode:'m <a href="Uwt_io.html#TYPEmode">mode</a> -> Uwt.file -> 'm <a href="Uwt_io.html#TYPEchannel">channel</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">of_file ?buffer ?close ~mode fd</code> creates a channel from a
      file descriptor.</p>
</div>
</div>
<div class="param_info"><code class="code">close</code> : defaults to closing the file descriptor.</div>

<pre><span id="VALof_stream"><span class="keyword">val</span> of_stream</span> : <code class="type">?buffer:<a href="Uwt_bytes.html#TYPEt">Uwt_bytes.t</a> -><br>       ?close:(unit -> unit Lwt.t) -><br>       mode:'m <a href="Uwt_io.html#TYPEmode">mode</a> -> <a href="Uwt.Stream.html#TYPEt">Uwt.Stream.t</a> -> 'm <a href="Uwt_io.html#TYPEchannel">channel</a></code></pre>
<pre><span id="VALof_pipe"><span class="keyword">val</span> of_pipe</span> : <code class="type">?buffer:<a href="Uwt_bytes.html#TYPEt">Uwt_bytes.t</a> -><br>       ?close:(unit -> unit Lwt.t) -><br>       mode:'m <a href="Uwt_io.html#TYPEmode">mode</a> -> <a href="Uwt.Pipe.html#TYPEt">Uwt.Pipe.t</a> -> 'm <a href="Uwt_io.html#TYPEchannel">channel</a></code></pre>
<pre><span id="VALof_tcp"><span class="keyword">val</span> of_tcp</span> : <code class="type">?buffer:<a href="Uwt_bytes.html#TYPEt">Uwt_bytes.t</a> -><br>       ?close:(unit -> unit Lwt.t) -><br>       mode:'m <a href="Uwt_io.html#TYPEmode">mode</a> -> <a href="Uwt.Tcp.html#TYPEt">Uwt.Tcp.t</a> -> 'm <a href="Uwt_io.html#TYPEchannel">channel</a></code></pre>
<pre><span id="VALclose"><span class="keyword">val</span> close</span> : <code class="type">'a <a href="Uwt_io.html#TYPEchannel">channel</a> -> unit Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">close ch</code> closes the given channel. If <code class="code">ch</code> is an output
      channel, it performs all pending actions, flushes it and closes
      it. If <code class="code">ch</code> is an input channel, it just closes it immediately.</p>

<p><code class="code">close</code> returns the result of the close function of the
      channel. Multiple calls to <code class="code">close</code> will return exactly the same
      value.</p>

<p>Note: you cannot use <code class="code">close</code> on channels obtained with
      <a href="Uwt_io.html#VALatomic"><code class="code">Uwt_io.atomic</code></a>.</p>
</div>
</div>

<pre><span id="VALabort"><span class="keyword">val</span> abort</span> : <code class="type">'a <a href="Uwt_io.html#TYPEchannel">channel</a> -> unit Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">abort ch</code> abort current operations and close the channel
      immediately.</p>
</div>
</div>

<pre><span id="VALatomic"><span class="keyword">val</span> atomic</span> : <code class="type">('a <a href="Uwt_io.html#TYPEchannel">channel</a> -> 'b Lwt.t) -> 'a <a href="Uwt_io.html#TYPEchannel">channel</a> -> 'b Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">atomic f</code> transforms a sequence of io operations into one
      single atomic io operation.</p>

<p>Note:</p>
<ul>
<li>the channel passed to <code class="code">f</code> is invalid after <code class="code">f</code> terminates</li>
<li><code class="code">atomic</code> can be called inside another <code class="code">atomic</code></li>
</ul>
</div>
</div>

<pre><span id="VALfile_length"><span class="keyword">val</span> file_length</span> : <code class="type">string -> int64 Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p>Retrieves the length of the file at the given path. If the path refers to a
    directory, the returned promise is rejected with
    <code class="code">Unix.(Unix_error (EISDIR, _, _))</code>.</p>
</div>
</div>

<pre><span id="VALbuffered"><span class="keyword">val</span> buffered</span> : <code class="type">'a <a href="Uwt_io.html#TYPEchannel">channel</a> -> int</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">buffered oc</code> returns the number of bytes in the buffer</p>
</div>
</div>

<pre><span id="VALflush"><span class="keyword">val</span> flush</span> : <code class="type"><a href="Uwt_io.html#TYPEoutput_channel">output_channel</a> -> unit Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">flush oc</code> performs all pending writes on <code class="code">oc</code></p>
</div>
</div>

<pre><span id="VALflush_all"><span class="keyword">val</span> flush_all</span> : <code class="type">unit -> unit Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">flush_all ()</code> flushes all open output channels</p>
</div>
</div>

<pre><span id="VALbuffer_size"><span class="keyword">val</span> buffer_size</span> : <code class="type">'a <a href="Uwt_io.html#TYPEchannel">channel</a> -> int</code></pre><div class="info ">
<div class="info-desc">
<p>Returns the size of the internal buffer.</p>
</div>
</div>

<pre><span id="VALresize_buffer"><span class="keyword">val</span> resize_buffer</span> : <code class="type">'a <a href="Uwt_io.html#TYPEchannel">channel</a> -> int -> unit Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p>Resize the internal buffer to the given size</p>
</div>
</div>

<pre><span id="VALis_busy"><span class="keyword">val</span> is_busy</span> : <code class="type">'a <a href="Uwt_io.html#TYPEchannel">channel</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">is_busy channel</code> returns whether the given channel is currently
      busy. A channel is busy when there is at least one job using it
      that has not yet terminated.</p>
</div>
</div>
<h3 id="2_Randomaccess">Random access</h3>
<pre><span id="VALposition"><span class="keyword">val</span> position</span> : <code class="type">'a <a href="Uwt_io.html#TYPEchannel">channel</a> -> int64</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">position ch</code> Returns the current position in the channel.</p>
</div>
</div>

<pre><span id="VALset_position"><span class="keyword">val</span> set_position</span> : <code class="type">'a <a href="Uwt_io.html#TYPEchannel">channel</a> -> int64 -> unit Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">set_position ch pos</code> Sets the position in the output channel. This
      does not work if the channel does not support random access.</p>
</div>
</div>

<pre><span id="VALlength"><span class="keyword">val</span> length</span> : <code class="type">'a <a href="Uwt_io.html#TYPEchannel">channel</a> -> int64 Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p>Returns the length of the channel in bytes</p>
</div>
</div>
<h3 id="2_Reading">Reading</h3><p>Note: except for functions dealing with streams (<a href="Uwt_io.html#VALread_chars"><code class="code">Uwt_io.read_chars</code></a> and
    <a href="Uwt_io.html#VALread_lines"><code class="code">Uwt_io.read_lines</code></a>) all functions are <b>atomic</b>.</p>

<pre><span id="VALread_char"><span class="keyword">val</span> read_char</span> : <code class="type"><a href="Uwt_io.html#TYPEinput_channel">input_channel</a> -> char Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">read_char ic</code> reads the next character of <code class="code">ic</code>.</p>
</div>
<ul class="info-attributes">
<li><b>Raises</b> <code>End_of_file</code> if the end of the file is reached</li>
</ul>
</div>

<pre><span id="VALread_char_opt"><span class="keyword">val</span> read_char_opt</span> : <code class="type"><a href="Uwt_io.html#TYPEinput_channel">input_channel</a> -> char option Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p>Same as <code class="code">read_byte</code> but does not raise <code class="code">End_of_file</code> on end of
      input</p>
</div>
</div>

<pre><span id="VALread_chars"><span class="keyword">val</span> read_chars</span> : <code class="type"><a href="Uwt_io.html#TYPEinput_channel">input_channel</a> -> char Lwt_stream.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">read_chars ic</code> returns a stream holding all characters of
      <code class="code">ic</code></p>
</div>
</div>

<pre><span id="VALread_line"><span class="keyword">val</span> read_line</span> : <code class="type"><a href="Uwt_io.html#TYPEinput_channel">input_channel</a> -> string Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">read_line ic</code> reads one complete line from <code class="code">ic</code> and returns it
      without the end of line. End of line is either <code class="code">"\n"</code> or
      <code class="code">"\r\n"</code>.</p>

<p>If the end of line is reached before reading any character,
      <code class="code">End_of_file</code> is raised. If it is reached before reading an end
      of line but characters have already been read, they are
      returned.</p>
</div>
</div>

<pre><span id="VALread_line_opt"><span class="keyword">val</span> read_line_opt</span> : <code class="type"><a href="Uwt_io.html#TYPEinput_channel">input_channel</a> -> string option Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p>Same as <a href="Uwt_io.html#VALread_line"><code class="code">Uwt_io.read_line</code></a> but do not raise <code class="code">End_of_file</code> on end of
      input.</p>
</div>
</div>

<pre><span id="VALread_lines"><span class="keyword">val</span> read_lines</span> : <code class="type"><a href="Uwt_io.html#TYPEinput_channel">input_channel</a> -> string Lwt_stream.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">read_lines ic</code> returns a stream holding all lines of <code class="code">ic</code></p>
</div>
</div>

<pre><span id="VALread"><span class="keyword">val</span> read</span> : <code class="type">?count:int -> <a href="Uwt_io.html#TYPEinput_channel">input_channel</a> -> string Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">read ?count ic</code> reads at most <code class="code">count</code> characters from <code class="code">ic</code>. It
      returns <code class="code">""</code> if the end of input is reached. If <code class="code">count</code> is not
      specified, it reads all bytes until the end of input.</p>
</div>
</div>

<pre><span id="VALread_into"><span class="keyword">val</span> read_into</span> : <code class="type"><a href="Uwt_io.html#TYPEinput_channel">input_channel</a> -> Bytes.t -> int -> int -> int Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">read_into ic buffer offset length</code> reads up to <code class="code">length</code> bytes,
      stores them in <code class="code">buffer</code> at offset <code class="code">offset</code>, and returns the
      number of bytes read.</p>

<p>Note: <code class="code">read_into</code> does not raise <code class="code">End_of_file</code>, it returns a
      length of <code class="code">0</code> instead.</p>
</div>
</div>

<pre><span id="VALread_into_exactly"><span class="keyword">val</span> read_into_exactly</span> : <code class="type"><a href="Uwt_io.html#TYPEinput_channel">input_channel</a> -> Bytes.t -> int -> int -> unit Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">read_into_exactly ic buffer offset length</code> reads exactly
      <code class="code">length</code> bytes and stores them in <code class="code">buffer</code> at offset <code class="code">offset</code>.</p>
</div>
<ul class="info-attributes">
<li><b>Raises</b> <code>End_of_file</code> on end of input</li>
</ul>
</div>

<pre><span id="VALread_value"><span class="keyword">val</span> read_value</span> : <code class="type"><a href="Uwt_io.html#TYPEinput_channel">input_channel</a> -> 'a Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">read_value channel</code> reads a marshaled value from <code class="code">channel</code>; it corresponds
    to the standard library's
    <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Marshal.html#VALfrom_channel"> <code class="code">Marshal.from_channel</code></a>.
    The corresponding writing function is <a href="Uwt_io.html#VALwrite_value"><code class="code">Uwt_io.write_value</code></a>.</p>

<p>Note that reading marshaled values is <em>not</em>, in general, type-safe. See
    the warning in the description of module
    <a href="https://caml.inria.fr/pub/docs/manual-ocaml/libref/Marshal.html">
    <code class="code">Marshal</code></a> for details. The short version is: if you read a value of one
    type, such as <code class="code">string</code>, when a value of another type, such as <code class="code">int</code> has
    actually been marshaled to <code class="code">channel</code>, you may get arbitrary behavior,
    including segmentation faults, access violations, security bugs, etc.</p>
</div>
</div>
<h3 id="2_Writing">Writing</h3><p>Note: as for reading functions, all functions except
    <a href="Uwt_io.html#VALwrite_chars"><code class="code">Uwt_io.write_chars</code></a> and <a href="Uwt_io.html#VALwrite_lines"><code class="code">Uwt_io.write_lines</code></a> are <b>atomic</b>.</p>

<p>For example if you use <a href="Uwt_io.html#VALwrite_line"><code class="code">Uwt_io.write_line</code></a> in two different threads, the
    two operations will be serialized, and lines cannot be mixed.</p>

<pre><span id="VALwrite_char"><span class="keyword">val</span> write_char</span> : <code class="type"><a href="Uwt_io.html#TYPEoutput_channel">output_channel</a> -> char -> unit Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">write_char oc char</code> writes <code class="code">char</code> on <code class="code">oc</code></p>
</div>
</div>

<pre><span id="VALwrite_chars"><span class="keyword">val</span> write_chars</span> : <code class="type"><a href="Uwt_io.html#TYPEoutput_channel">output_channel</a> -> char Lwt_stream.t -> unit Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">write_chars oc chars</code> writes all characters of <code class="code">chars</code> on
      <code class="code">oc</code></p>
</div>
</div>

<pre><span id="VALwrite"><span class="keyword">val</span> write</span> : <code class="type"><a href="Uwt_io.html#TYPEoutput_channel">output_channel</a> -> string -> unit Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">write oc str</code> writes all characters of <code class="code">str</code> on <code class="code">oc</code></p>
</div>
</div>

<pre><span id="VALwrite_line"><span class="keyword">val</span> write_line</span> : <code class="type"><a href="Uwt_io.html#TYPEoutput_channel">output_channel</a> -> string -> unit Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">write_line oc str</code> writes <code class="code">str</code> on <code class="code">oc</code> followed by a
      new-line.</p>
</div>
</div>

<pre><span id="VALwrite_lines"><span class="keyword">val</span> write_lines</span> : <code class="type"><a href="Uwt_io.html#TYPEoutput_channel">output_channel</a> -> string Lwt_stream.t -> unit Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">write_lines oc lines</code> writes all lines of <code class="code">lines</code> to <code class="code">oc</code></p>
</div>
</div>

<pre><span id="VALwrite_from"><span class="keyword">val</span> write_from</span> : <code class="type"><a href="Uwt_io.html#TYPEoutput_channel">output_channel</a> -> Bytes.t -> int -> int -> int Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">write_from oc buffer offset length</code> writes up to <code class="code">length</code> bytes
      to <code class="code">oc</code>, from <code class="code">buffer</code> at offset <code class="code">offset</code> and returns the number
      of bytes actually written</p>
</div>
</div>

<pre><span id="VALwrite_from_string"><span class="keyword">val</span> write_from_string</span> : <code class="type"><a href="Uwt_io.html#TYPEoutput_channel">output_channel</a> -> string -> int -> int -> int Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p>See <a href="Uwt_io.html#VALwrite"><code class="code">Uwt_io.write</code></a>.</p>
</div>
</div>

<pre><span id="VALwrite_from_exactly"><span class="keyword">val</span> write_from_exactly</span> : <code class="type"><a href="Uwt_io.html#TYPEoutput_channel">output_channel</a> -> Bytes.t -> int -> int -> unit Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">write_from_exactly oc buffer offset length</code> writes all <code class="code">length</code>
      bytes from <code class="code">buffer</code> at offset <code class="code">offset</code> to <code class="code">oc</code></p>
</div>
</div>

<pre><span id="VALwrite_from_string_exactly"><span class="keyword">val</span> write_from_string_exactly</span> : <code class="type"><a href="Uwt_io.html#TYPEoutput_channel">output_channel</a> -> string -> int -> int -> unit Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p>See <a href="Uwt_io.html#VALwrite_from_exactly"><code class="code">Uwt_io.write_from_exactly</code></a>.</p>
</div>
</div>

<pre><span id="VALwrite_value"><span class="keyword">val</span> write_value</span> : <code class="type"><a href="Uwt_io.html#TYPEoutput_channel">output_channel</a> -> ?flags:Marshal.extern_flags list -> 'a -> unit Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">write_value oc ?flags x</code> marshals the value <code class="code">x</code> to <code class="code">oc</code></p>
</div>
</div>
<h3 id="2_Printing">Printing</h3><p>These functions are basically helpers. Also you may prefer
    using the name <a href="Uwt_io.html#VALprintl"><code class="code">Uwt_io.printl</code></a> rather than <a href="Uwt_io.html#VALwrite_line"><code class="code">Uwt_io.write_line</code></a> because it is
    shorter.</p>

<p>The general name of a printing function is <code class="code">&lt;prefix&gt;print&lt;suffixes&gt;</code>,</p>

<p>where <code class="code">&lt;prefix&gt;</code> is one of:</p>
<ul>
<li><code class="code">'f'</code>, which means that the function takes as argument a channel</li>
<li>nothing, which means that the function prints on <a href="Uwt_io.html#VALstdout"><code class="code">Uwt_io.stdout</code></a></li>
<li><code class="code">'e'</code>, which means that the function prints on <a href="Uwt_io.html#VALstderr"><code class="code">Uwt_io.stderr</code></a></li>
</ul>
<p>and <code class="code">&lt;suffixes&gt;</code> is a combination of:</p>
<ul>
<li><code class="code">'l'</code> which means that a new-line character is printed after the message</li>
<li><code class="code">'f'</code> which means that the function takes as argument a <b>format</b> instead
    of a string</li>
</ul>

<pre><span id="VALfprint"><span class="keyword">val</span> fprint</span> : <code class="type"><a href="Uwt_io.html#TYPEoutput_channel">output_channel</a> -> string -> unit Lwt.t</code></pre>
<pre><span id="VALfprintl"><span class="keyword">val</span> fprintl</span> : <code class="type"><a href="Uwt_io.html#TYPEoutput_channel">output_channel</a> -> string -> unit Lwt.t</code></pre>
<pre><span id="VALfprintf"><span class="keyword">val</span> fprintf</span> : <code class="type"><a href="Uwt_io.html#TYPEoutput_channel">output_channel</a> -><br>       ('a, unit, string, unit Lwt.t) Pervasives.format4 -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">%!</code> does nothing here. To flush the channel, use <code class="code">Uwt_io.flush channel</code>.</p>
</div>
</div>

<pre><span id="VALfprintlf"><span class="keyword">val</span> fprintlf</span> : <code class="type"><a href="Uwt_io.html#TYPEoutput_channel">output_channel</a> -><br>       ('a, unit, string, unit Lwt.t) Pervasives.format4 -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">%!</code> does nothing here. To flush the channel, use <code class="code">Uwt_io.flush channel</code>.</p>
</div>
</div>

<pre><span id="VALprint"><span class="keyword">val</span> print</span> : <code class="type">string -> unit Lwt.t</code></pre>
<pre><span id="VALprintl"><span class="keyword">val</span> printl</span> : <code class="type">string -> unit Lwt.t</code></pre>
<pre><span id="VALprintf"><span class="keyword">val</span> printf</span> : <code class="type">('a, unit, string, unit Lwt.t) Pervasives.format4 -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">%!</code> does nothing here. To flush the channel, use <code class="code">Uwt_io.(flush stdout)</code>.</p>
</div>
</div>

<pre><span id="VALprintlf"><span class="keyword">val</span> printlf</span> : <code class="type">('a, unit, string, unit Lwt.t) Pervasives.format4 -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">%!</code> does nothing here. To flush the channel, use <code class="code">Uwt_io.flush channel</code>.</p>
</div>
</div>

<pre><span id="VALeprint"><span class="keyword">val</span> eprint</span> : <code class="type">string -> unit Lwt.t</code></pre>
<pre><span id="VALeprintl"><span class="keyword">val</span> eprintl</span> : <code class="type">string -> unit Lwt.t</code></pre>
<pre><span id="VALeprintf"><span class="keyword">val</span> eprintf</span> : <code class="type">('a, unit, string, unit Lwt.t) Pervasives.format4 -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">%!</code> does nothing here. To flush the channel, use <code class="code">Uwt_io.(flush stderr)</code>.</p>
</div>
</div>

<pre><span id="VALeprintlf"><span class="keyword">val</span> eprintlf</span> : <code class="type">('a, unit, string, unit Lwt.t) Pervasives.format4 -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">%!</code> does nothing here. To flush the channel, use <code class="code">Uwt_io.(flush stderr)</code>.</p>
</div>
</div>
<h3 id="2_Utilities">Utilities</h3>
<pre><span id="VALhexdump_stream"><span class="keyword">val</span> hexdump_stream</span> : <code class="type"><a href="Uwt_io.html#TYPEoutput_channel">output_channel</a> -> char Lwt_stream.t -> unit Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">hexdump_stream oc byte_stream</code> produces the same output as the
      command <code class="code">hexdump -C</code>.</p>
</div>
</div>

<pre><span id="VALhexdump"><span class="keyword">val</span> hexdump</span> : <code class="type"><a href="Uwt_io.html#TYPEoutput_channel">output_channel</a> -> string -> unit Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">hexdump oc str = hexdump_stream oc (Lwt_stream.of_string str)</code></p>
</div>
</div>
<h3 id="2_Fileutilities">File utilities</h3>
<pre><span id="TYPEfile_name"><span class="keyword">type</span> <code class="type"></code>file_name</span> = <code class="type">string</code> </pre>
<div class="info ">
<div class="info-desc">
<p>Type of file names</p>
</div>
</div>


<pre><span id="VALopen_file"><span class="keyword">val</span> open_file</span> : <code class="type">?buffer:<a href="Uwt_bytes.html#TYPEt">Uwt_bytes.t</a> -><br>       ?flags:Uwt.Fs.uv_open_flag list -><br>       ?perm:Unix.file_perm -><br>       mode:'a <a href="Uwt_io.html#TYPEmode">mode</a> -> <a href="Uwt_io.html#TYPEfile_name">file_name</a> -> 'a <a href="Uwt_io.html#TYPEchannel">channel</a> Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">open_file ?buffer ?flags ?perm ~mode filename</code> opens the file with name
    <code class="code">filename</code>, and returns a channel for either reading or writing it.</p>

<p>Note: if opening for writing (<code class="code">~mode:Output</code>), and the file already exists,
    <code class="code">open_file</code> truncates (clears) the file by default. If you would like to
    keep the pre-existing contents of the file, use the <code class="code">?flags</code> parameter to
    pass a custom flags list that does not include <code class="code">Unix.O_TRUNC</code>.</p>
</div>
<ul class="info-attributes">
<li><b>Raises</b> <code>Unix.Unix_error</code> on error.</li>
</ul>
</div>

<pre><span id="VALwith_file"><span class="keyword">val</span> with_file</span> : <code class="type">?buffer:<a href="Uwt_bytes.html#TYPEt">Uwt_bytes.t</a> -><br>       ?flags:Uwt.Fs.uv_open_flag list -><br>       ?perm:Unix.file_perm -><br>       mode:'a <a href="Uwt_io.html#TYPEmode">mode</a> -><br>       <a href="Uwt_io.html#TYPEfile_name">file_name</a> -> ('a <a href="Uwt_io.html#TYPEchannel">channel</a> -> 'b Lwt.t) -> 'b Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">with_file ?buffer ?flags ?perm ~mode filename f</code> opens a file and passes
    the channel to <code class="code">f</code>. It is ensured that the channel is closed when <code class="code">f ch</code>
    resolves (even if it is rejected, or if <code class="code">f</code> raises an exception).</p>

<p>Note: if opening for writing (<code class="code">~mode:Output</code>), and the file already exists,
    <code class="code">with_file</code> truncates (clears) the file by default. If you would like to
    keep the pre-existing contents of the file, use the <code class="code">?flags</code> parameter to
    pass a custom flags list that does not include <code class="code">Unix.O_TRUNC</code>.</p>
</div>
</div>

<pre><span id="VALopen_temp_file"><span class="keyword">val</span> open_temp_file</span> : <code class="type">?buffer:<a href="Uwt_bytes.html#TYPEt">Uwt_bytes.t</a> -><br>       ?flags:Uwt.Fs.uv_open_flag list -><br>       ?perm:Unix.file_perm -><br>       ?temp_dir:string -><br>       ?prefix:string -> unit -> (string * <a href="Uwt_io.html#TYPEoutput_channel">output_channel</a>) Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">open_temp_file ()</code> starts creating a new temporary file, and evaluates to a
    promise for the pair of the file's name, and an output channel for writing
    to the file.</p>

<p>The caller should take care to delete the file later. Alternatively, see
    <a href="Uwt_io.html#VALwith_temp_file"><code class="code">Uwt_io.with_temp_file</code></a>.</p>

<p>The <code class="code">?buffer</code> and <code class="code">?perm</code> arguments are passed directly to an internal call
    to <code class="code">Uwt.io.open_file</code>.</p>

<p>If not specified, <code class="code">?flags</code> defaults to
    <code class="code">[O_CREAT; O_EXCL; O_WRONLY]</code>. If specified, the specified flags
    are used exactly. Note that these should typically contain at least
    <code class="code">O_CREAT</code> and <code class="code">O_EXCL</code>, otherwise <code class="code">open_temp_file</code> may open an existing
    file.</p>

<p><code class="code">?temp_dir</code> can be used to choose the directory in which the file is
    created. For the current directory, use
    <a href=" https://caml.inria.fr/pub/docs/manual-ocaml/libref/Filename.html#VALcurrent_dir_name">
    <code class="code">Filename.current_dir_name</code></a>. If not specified, the directory is taken from
    <a href=" https://caml.inria.fr/pub/docs/manual-ocaml/libref/Filename.html#VALget_temp_dir_name">
    <code class="code">Filename.get_temp_dir_name</code></a>, which is typically set to your system
    temporary file directory.</p>

<p><code class="code">?prefix</code> helps determine the name of the file. It will be the prefix
    concatenated with a random sequence of characters. If not specified,
    <code class="code">open_temp_file</code> uses some default prefix.</p>
</div>
</div>

<pre><span id="VALwith_temp_file"><span class="keyword">val</span> with_temp_file</span> : <code class="type">?buffer:<a href="Uwt_bytes.html#TYPEt">Uwt_bytes.t</a> -><br>       ?flags:Uwt.Fs.uv_open_flag list -><br>       ?perm:Unix.file_perm -><br>       ?temp_dir:string -><br>       ?prefix:string -> (string * <a href="Uwt_io.html#TYPEoutput_channel">output_channel</a> -> 'b Lwt.t) -> 'b Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">with_temp_file f</code> calls <a href="Uwt_io.html#VALopen_temp_file"><code class="code">Uwt_io.open_temp_file</code></a><code class="code"> ()</code>, passing all optional
    arguments directly to it. It then attaches <code class="code">f</code> to run after the file is
    created, passing the filename and output channel to <code class="code">f</code>. When the promise
    returned by <code class="code">f</code> is resolved, <code class="code">with_temp_file</code> closes the channel and deletes
    the temporary file by calling <code class="code">Uwt.Fs.unlink</code>.</p>
</div>
</div>

<pre><span id="VALopen_connection"><span class="keyword">val</span> open_connection</span> : <code class="type">?in_buffer:<a href="Uwt_bytes.html#TYPEt">Uwt_bytes.t</a> -><br>       ?out_buffer:<a href="Uwt_bytes.html#TYPEt">Uwt_bytes.t</a> -><br>       Unix.sockaddr -> (<a href="Uwt_io.html#TYPEinput_channel">input_channel</a> * <a href="Uwt_io.html#TYPEoutput_channel">output_channel</a>) Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">open_connection ?in_buffer ?out_buffer addr</code> opens a connection to the
    given address and returns two channels for using it.</p>

<p>The connection is completly closed when you close both
    channels.</p>
</div>
<ul class="info-attributes">
<li><b>Raises</b> <code>Unix.Unix_error</code> on error.</li>
</ul>
</div>

<pre><span id="VALwith_connection"><span class="keyword">val</span> with_connection</span> : <code class="type">?in_buffer:<a href="Uwt_bytes.html#TYPEt">Uwt_bytes.t</a> -><br>       ?out_buffer:<a href="Uwt_bytes.html#TYPEt">Uwt_bytes.t</a> -><br>       Unix.sockaddr -><br>       (<a href="Uwt_io.html#TYPEinput_channel">input_channel</a> * <a href="Uwt_io.html#TYPEoutput_channel">output_channel</a> -> 'a Lwt.t) -> 'a Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">with_connection ?fd ?in_buffer ?out_buffer addr f</code> opens a connection to
      the given address and passes the channels to <code class="code">f</code></p>
</div>
</div>

<pre><span id="TYPEserver"><span class="keyword">type</span> <code class="type"></code>server</span> </pre>
<div class="info ">
<div class="info-desc">
<p>Type of a server</p>
</div>
</div>


<pre><span id="VALestablish_server_with_client_address"><span class="keyword">val</span> establish_server_with_client_address</span> : <code class="type">?buffer_size:int -><br>       ?backlog:int -><br>       ?no_close:bool -><br>       Unix.sockaddr -><br>       (Unix.sockaddr -> <a href="Uwt_io.html#TYPEinput_channel">input_channel</a> * <a href="Uwt_io.html#TYPEoutput_channel">output_channel</a> -> unit Lwt.t) -><br>       <a href="Uwt_io.html#TYPEserver">server</a> Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">establish_server_with_client_address listen_address f</code> creates a server
    which listens for incoming connections on <code class="code">listen_address</code>. When a client
    makes a new connection, it is passed to <code class="code">f</code>: more precisely, the server
    calls</p>

<pre class="codepre"><code class="code">f client_address (in_channel, out_channel)
</code></pre>
<p>where <code class="code">client_address</code> is the address (peer name) of the new client, and
    <code class="code">in_channel</code> and <code class="code">out_channel</code> are two channels wrapping the socket for
    communicating with that client.</p>

<p>The server does not block waiting for <code class="code">f</code> to complete: it concurrently tries
    to accept more client connections while <code class="code">f</code> is handling the client.</p>

<p>When the promise returned by <code class="code">f</code> completes (i.e., <code class="code">f</code> is done handling the
    client), <code class="code">establish_server_with_client_address</code> automatically closes
    <code class="code">in_channel</code> and <code class="code">out_channel</code>. This is a default behavior that is useful
    for simple cases, but for a robust application you should explicitly close
    these channels yourself, and handle any exceptions. If the channels are
    still open when <code class="code">f</code> completes, and their automatic closing raises an
    exception, <code class="code">establish_server_with_client_address</code> treats it as an unhandled
    exception reaching the top level of the application: it passes that
    exception to <code class="code">Lwt.async_exception_hook</code>, the default behavior of which is
    to print the exception and <em>terminate your process</em>.</p>

<p>Automatic closing can be completely disabled by passing <code class="code">~no_close:true</code>.</p>

<p>Similarly, if <code class="code">f</code> raises an exception (or the promise it returns fails with
    an exception), <code class="code">establish_server_with_client_address</code> can do nothing with
    that exception, except pass it to <code class="code">Lwt.async_exception_hook</code>.</p>

<p><code class="code">~backlog</code> is the argument passed to <code class="code">Lwt_unix.listen</code>.</p>

<p>The returned promise (a <code class="code">server Lwt.t</code>) resolves when the server has just
    started listening on <code class="code">listen_address</code>: right after the internal call to
    <code class="code">listen</code>, and right before the first internal call to <code class="code">accept</code>.</p>
</div>
</div>

<pre><span id="VALestablish_server"><span class="keyword">val</span> establish_server</span> : <code class="type">?buffer_size:int -><br>       ?backlog:int -><br>       ?no_close:bool -><br>       Unix.sockaddr -><br>       (<a href="Uwt_io.html#TYPEinput_channel">input_channel</a> * <a href="Uwt_io.html#TYPEoutput_channel">output_channel</a> -> unit Lwt.t) -><br>       <a href="Uwt_io.html#TYPEserver">server</a> Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p>Like <code class="code">establish_server_with_client_address</code>, but does not pass the client
    address to the callback <code class="code">f</code>.</p>
</div>
</div>

<pre><span id="VALshutdown_server"><span class="keyword">val</span> shutdown_server</span> : <code class="type"><a href="Uwt_io.html#TYPEserver">server</a> -> unit Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p>Shutdown the given server</p>
</div>
</div>

<pre><span id="VALlines_of_file"><span class="keyword">val</span> lines_of_file</span> : <code class="type"><a href="Uwt_io.html#TYPEfile_name">file_name</a> -> string Lwt_stream.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">lines_of_file name</code> returns a stream of all lines of the file
      with name <code class="code">name</code>. The file is automatically closed when all
      lines have been read.</p>
</div>
</div>

<pre><span id="VALlines_to_file"><span class="keyword">val</span> lines_to_file</span> : <code class="type"><a href="Uwt_io.html#TYPEfile_name">file_name</a> -> string Lwt_stream.t -> unit Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">lines_to_file name lines</code> writes all lines of <code class="code">lines</code> to
      file with name <code class="code">name</code>.</p>
</div>
</div>

<pre><span id="VALchars_of_file"><span class="keyword">val</span> chars_of_file</span> : <code class="type"><a href="Uwt_io.html#TYPEfile_name">file_name</a> -> char Lwt_stream.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">chars_of_file name</code> returns a stream of all characters of the
      file with name <code class="code">name</code>. As for <a href="Uwt_io.html#VALlines_of_file"><code class="code">Uwt_io.lines_of_file</code></a> the file is
      closed when all characters have been read.</p>
</div>
</div>

<pre><span id="VALchars_to_file"><span class="keyword">val</span> chars_to_file</span> : <code class="type"><a href="Uwt_io.html#TYPEfile_name">file_name</a> -> char Lwt_stream.t -> unit Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">chars_to_file name chars</code> writes all characters of <code class="code">chars</code> to
      <code class="code">name</code></p>
</div>
</div>
<h3 id="2_Inputoutputofintegers">Input/output of integers</h3>
<pre><span id="MODULETYPENumberIO"><span class="keyword">module type</span> <a href="Uwt_io.NumberIO.html">NumberIO</a></span> = <code class="code">sig</code> <a href="Uwt_io.NumberIO.html">..</a> <code class="code">end</code></pre><div class="info">
<p>Common interface for reading/writing integers in binary</p>

</div>

<pre><span id="MODULELE"><span class="keyword">module</span> <a href="Uwt_io.LE.html">LE</a></span>: <code class="type"><a href="Uwt_io.NumberIO.html">NumberIO</a></code><code class="type"> </code></pre><div class="info">
<p>Reading/writing of numbers in little-endian</p>

</div>

<pre><span id="MODULEBE"><span class="keyword">module</span> <a href="Uwt_io.BE.html">BE</a></span>: <code class="type"><a href="Uwt_io.NumberIO.html">NumberIO</a></code><code class="type"> </code></pre><div class="info">
<p>Reading/writing of numbers in big-endian</p>

</div>

<pre><span class="keyword">include</span> <a href="Uwt_io.NumberIO.html">Uwt_io.NumberIO</a></pre>
<p>Reading/writing of numbers in the system endianness.</p>

<pre><code><span id="TYPEbyte_order"><span class="keyword">type</span> <code class="type"></code>byte_order</span> = </code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbyte_order.Little_endian"><span class="constructor">Little_endian</span></span></code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code><span class="keyword">|</span></code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTbyte_order.Big_endian"><span class="constructor">Big_endian</span></span></code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>Type of byte order</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>



<pre><span id="VALsystem_byte_order"><span class="keyword">val</span> system_byte_order</span> : <code class="type"><a href="Uwt_io.html#TYPEbyte_order">byte_order</a></code></pre><h3 id="2_Lowlevelaccesstotheinternalbuffer">Low-level access to the internal buffer</h3>
<pre><span id="VALblock"><span class="keyword">val</span> block</span> : <code class="type">'a <a href="Uwt_io.html#TYPEchannel">channel</a> -> int -> (<a href="Uwt_bytes.html#TYPEt">Uwt_bytes.t</a> -> int -> 'b Lwt.t) -> 'b Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">block ch size f</code> pass to <code class="code">f</code> the internal buffer and an
      offset. The buffer contains <code class="code">size</code> chars at <code class="code">offset</code>. <code class="code">f</code> may
      read or write these chars.  <code class="code">size</code> must satisfy <code class="code">0 &lt;= size &lt;=
      16</code></p>
</div>
</div>

<pre><code><span id="TYPEdirect_access"><span class="keyword">type</span> <code class="type"></code>direct_access</span> = {</code></pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTdirect_access.da_buffer">da_buffer</span>&nbsp;: <code class="type"><a href="Uwt_bytes.html#TYPEt">Uwt_bytes.t</a></code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The internal buffer</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTdirect_access.da_ptr">da_ptr</span>&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The pointer to:</p>
<ul>
<li>the beginning of free space for output channels</li>
<li>the beginning of data for input channels</li>
</ul>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTdirect_access.da_max">da_max</span>&nbsp;: <code class="type">int</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>The maximum offset</p>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTdirect_access.da_perform">da_perform</span>&nbsp;: <code class="type">unit -> int Lwt.t</code>;</code></td>
<td class="typefieldcomment" align="left" valign="top" ><code>(*</code></td><td class="typefieldcomment" align="left" valign="top" ><div class="info ">
<div class="info-desc">
<p>- for input channels:
        refills the buffer and returns how many bytes have been read</p>
<ul>
<li>for output channels:
        flush partially the buffer and returns how many bytes have been written</li>
</ul>
</div>
</div>
</td><td class="typefieldcomment" align="left" valign="bottom" ><code>*)</code></td>
</tr></table>
}

<div class="info ">
<div class="info-desc">
<p>Information for directly accessing the internal buffer of a
    channel</p>
</div>
</div>


<pre><span id="VALdirect_access"><span class="keyword">val</span> direct_access</span> : <code class="type">'a <a href="Uwt_io.html#TYPEchannel">channel</a> -> (<a href="Uwt_io.html#TYPEdirect_access">direct_access</a> -> 'b Lwt.t) -> 'b Lwt.t</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">direct_access ch f</code> passes to <code class="code">f</code> a <a href="Uwt_io.html#VALdirect_access"><code class="code">Uwt_io.direct_access</code></a>
      structure. <code class="code">f</code> must use it and update <code class="code">da_ptr</code> to reflect how
      many bytes have been read/written.</p>
</div>
</div>
<h3 id="2_Misc">Misc</h3>
<pre><span id="VALdefault_buffer_size"><span class="keyword">val</span> default_buffer_size</span> : <code class="type">unit -> int</code></pre><div class="info ">
<div class="info-desc">
<p>Return the default size for buffers. Channels that are created
      without a specific buffer use new buffer of this size.</p>
</div>
</div>

<pre><span id="VALset_default_buffer_size"><span class="keyword">val</span> set_default_buffer_size</span> : <code class="type">int -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Change the default buffer size.</p>
</div>
<ul class="info-attributes">
<li><b>Raises</b> <code>Invalid_argument</code> if the given size is smaller than <code class="code">16</code>
      or greater than <code class="code">Sys.max_string_length</code></li>
</ul>
</div>
</body></html>